use super::request::*;
use super::sessions::Session;
use crate::gemini::error::GeminiResponseStreamError;
use bytes::Bytes;
use derive_new::new;
use futures::Stream;
use reqwest::Response;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::{
    pin::Pin,
    task::{Context, Poll},
};

#[derive(Serialize, Deserialize, Clone, Debug)]
#[allow(non_camel_case_types)]
pub enum FinishReason {
    /// Default value. This value is unused.
    FINISH_REASON_UNSPECIFIED,
    /// Natural stop point of the model or provided stop sequence.
    STOP,
    /// The maximum number of tokens as specified in the request was reached.
    MAX_TOKENS,
    /// The response candidate content was flagged for safety reasons.
    SAFETY,
    /// The response candidate content was flagged for recitation reasons.
    RECITATION,
    /// The response candidate content was flagged for using an unsupported language.
    LANGUAGE,
    /// Unknown reason.
    OTHER,
    /// Token generation stopped because the content contains forbidden terms.
    BLOCKLIST,
    /// Token generation stopped for potentially containing prohibited content.
    PROHIBITED_CONTENT,
    /// Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
    SPII,
    /// The function call generated by the model is invalid.
    MALFORMED_FUNCTION_CALL,
    /// Token generation stopped because generated images contain safety violations.
    IMAGE_SAFETY,
}

#[derive(Serialize, Deserialize, Clone, Debug, new)]
#[allow(non_snake_case)]
struct Candidate {
    content: Chat,
    pub finishReason: Option<FinishReason>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[allow(non_snake_case)]
pub struct GeminiResponse {
    candidates: Vec<Candidate>,
    pub usageMetadata: Value,
    pub modelVersion: String,
    pub promptFeedback: Option<Value>,
}
impl GeminiResponse {
    pub(crate) async fn new(response: Response) -> Result<GeminiResponse, reqwest::Error> {
        response.json().await
    }
    pub(crate) fn from_str(string: impl AsRef<str>) -> Result<Self, serde_json::Error> {
        serde_json::from_str(string.as_ref())
    }
    pub fn get_parts(&self) -> &Vec<Part> {
        self.candidates[0].content.parts()
    }
    pub fn get_json<T>(&self) -> Result<T, serde_json::Error>
    where
        T: serde::de::DeserializeOwned,
    {
        let unescaped_str = self.get_text("").replace("\\\"", "\"").replace("\\n", "\n");
        serde_json::from_str::<T>(&unescaped_str)
    }
    pub fn parse_json<T>(parts: &[Part]) -> Result<T, serde_json::Error>
    where
        T: serde::de::DeserializeOwned,
    {
        let unescaped_str = Self::extract_text(parts, "")
            .replace("\\\"", "\"")
            .replace("\\n", "\n");
        serde_json::from_str::<T>(&unescaped_str)
    }
    ///`seperator` used to concatenate all text parts. TL;DR use "" as seperator.
    pub fn extract_text(parts: &[Part], seperator: impl AsRef<str>) -> String {
        let mut concatenated_string = String::new();
        for part in parts {
            if let Part::text(text) = part {
                concatenated_string.push_str(text);
                concatenated_string.push_str(seperator.as_ref());
            }
        }
        concatenated_string
    }
    ///`seperator` used to concatenate all text parts. TL;DR use "" as seperator.
    pub fn get_text(&self, seperator: impl AsRef<str>) -> String {
        Self::extract_text(&self.get_parts(), seperator.as_ref())
    }
}

pub type StreamDataExtractor<'a, T> = Box<dyn FnMut(&Session, GeminiResponse) -> T + 'a>;
pin_project_lite::pin_project! {
#[derive(new)]
    pub struct GeminiResponseStream<'a, T>{
        #[pin]
        response_stream:Box<dyn Stream<Item = Result<Bytes, reqwest::Error>> + Unpin + Send + 'static>,
        session: Session,
        data_extractor: StreamDataExtractor<'a,T>
    }
}
impl<'a, T> Stream for GeminiResponseStream<'a, T> {
    type Item = Result<T, GeminiResponseStreamError>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let this = self.project();

        match this.response_stream.poll_next(cx) {
            Poll::Ready(Some(Ok(bytes))) => {
                let text = String::from_utf8_lossy(&bytes);
                if text == "]" {
                    Poll::Ready(None)
                } else {
                    let json_string = text[1..].trim();
                    let response = GeminiResponse::from_str(json_string)
                        .map_err(|_| json_string.to_string())?;
                    this.session.update(&response);
                    let data = (this.data_extractor)(&this.session, response);
                    Poll::Ready(Some(Ok(data)))
                }
            }
            Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(e.into()))),
            Poll::Ready(None) => Poll::Ready(None),
            Poll::Pending => Poll::Pending,
        }
    }
}
impl<'a, T> GeminiResponseStream<'a, T> {
    pub fn get_session(&self) -> &Session {
        &self.session
    }
    pub fn get_session_owned(self) -> Session {
        self.session
    }
}
